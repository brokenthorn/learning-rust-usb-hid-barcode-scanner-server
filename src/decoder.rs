use base_encode::decode;
use derive_more::Display;

/// Supported barcode symbologies in AIM format.
#[derive(Debug, Display)]
pub enum AimSymbology {
    /// DataMatrix d0: ECC 000-140.
    DataMatrixD0Ecc000140,
    /// DataMatrix d1: ECC 200.
    DataMatrixD1Ecc200,
    /// DataMatrix d2: ECC 200, FNC1 in first or fifth position.
    DataMatrixD2Ecc200Fnc1FirstOrFifth,
    /// DataMatrix d3: ECC 200, FNC1 in second or sixth position.
    DataMatrixD3Ecc200Fnc1SecondOrSixth,
    /// DataMatrix d4: ECC 200, ECI protocol implemented.
    DataMatrixD4Ecc200Eci,
    /// DataMatrix d5: ECC 200, FNC1 in first or fifth position, ECI protocol implemented.
    DataMatrixD5Ecc200Fnc1FirstOrFifthEci,
    /// DataMatrix d6: ECC 200, FNC1 in second or sixth position, ECI protocol implemented.
    DataMatrixD6Fnc1SecondOrSixthEci,
    /// GS1 DataBar Omnidirectional, GS1 DataBar Limited.
    DataBar,
    /// Unknown symbology.
    Unknown,
}

/// Decodes symbology type using AIM code identifiers.
///
/// # AIM codes
///
/// The AIM identifier is not part of a barcode. It is generated by the decoder of a scan engine to
/// represent the barcode symbology which was scanned.
///
/// Based on the AIM identifier, wedge software or terminal emulation software might be set up to
/// process scanned data in a user-defined way.
///
/// ## NOTE
///
/// Barcode scanners may also generate 1-character barcode identifiers instead of the
/// 3-character AIM identifier.
/// The actual characters used are defined by the manufacturer of that scan engine and might be
/// different, depending on that manufacturer.
///
/// Each AIM code identifier contains the three-character string `]cm` where:
///
/// * `]` &rArr; Flag Character (ASCII 93)
/// * `c` &rArr; Code Character
/// * `m` &rArr; Modifier Character
///
/// # Code characters
///
///
pub fn decode_aim_symbology(identifier: &[u8]) -> AimSymbology {
    match identifier {
        [0x5d, 0x64, 0x30] => AimSymbology::DataMatrixD0Ecc000140,
        [0x5d, 0x64, 0x31] => AimSymbology::DataMatrixD1Ecc200,
        [0x5d, 0x64, 0x32] => AimSymbology::DataMatrixD2Ecc200Fnc1FirstOrFifth,
        [0x5d, 0x64, 0x33] => AimSymbology::DataMatrixD3Ecc200Fnc1SecondOrSixth,
        [0x5d, 0x64, 0x34] => AimSymbology::DataMatrixD4Ecc200Eci,
        [0x5d, 0x64, 0x35] => AimSymbology::DataMatrixD5Ecc200Fnc1FirstOrFifthEci,
        [0x5d, 0x64, 0x36] => AimSymbology::DataMatrixD6Fnc1SecondOrSixthEci,
        [0x5d, 0x45, 0x30] => AimSymbology::DataBar,
        _ => AimSymbology::Unknown,
    }
}

pub fn decode_base256(buf: &[u8]) -> Option<Vec<u8>> {
    decode(buf, 255)
}

pub fn unzip_bytes(buf: &[u8]) -> zip::result::ZipResult<()> {
    use std::io::prelude::*;

    let reader = std::io::Cursor::new(buf);

    let mut zip = zip::ZipArchive::new(reader)?;

    for i in 0..zip.len() {
        let file = zip.by_index(i).unwrap();
        println!("Filename: {}", file.name());
        let first_byte = file.bytes().next().unwrap()?;
        println!("{}", first_byte);
    }

    Ok(())
}
