#[macro_use]
extern crate counted_array;
use crate::constants::{INTERMEC_VID, SG20_PID, SUPPORTED_VIDS};
use tracing::{debug, info, Level};
use tracing_subscriber::FmtSubscriber;

// USB HID POS: (in Honeywell user guides referenced as USB HID / USB HID Bar Code Scanner)
//
// The USB HID POS (131) interface also referred to as HID COM, is the most underestimated
// and less used interface.
//
// Technically it is familiar to HID keyboard but then without keyboard overhead which makes it much faster.
// Today only a few software applications actually use this interface.
// USB HID POS conforms to the USB standard document "HID Point of Sales Usage Tables" V1.02 HID POS
// is the official USB method for connecting a bar code reader:
// https://honeywellsps.my.salesforce.com/sfc/p/00000000SK3U/a/A00000000FNw/srkiB9jggTCjK25Fza0x2cXvIu_OtkSif6_vGebuBzA
// https://jpgraph.net/download/manuals/chunkhtml/ch26.html
//
// The maximum capacity for Data Matrix codes is up to 3116 numeric characters or up to 2335
// alphanumeric characters or up to 1555 bytes of binary information.
//
// The exact number of characters that can fit in a Data Matrix symbol depends on the actual encoding
// (or compaction) schema used. In short this is used to more efficiently encode ASCII characters
// to fit more data into a fixed number of bytes. For example if only numeric data is to be encoded
// then instead of using one byte to hold each digit two digits is stored in a single byte
// hence doubling the amount of data that can be stored in a given number of bytes.

pub mod constants;
//pub mod device;
//pub mod server;

#[derive(Debug)]
pub enum Symbology {
    /// DataMatrix d0: ECC 000-140.
    DataMatrixD0Ecc000140,
    /// DataMatrix d1: ECC 200.
    DataMatrixD1Ecc200,
    /// DataMatrix d2: ECC 200, FNC1 in first or fifth position.
    DataMatrixD2Ecc200Fnc1FirstOrFifth,
    /// DataMatrix d3: ECC 200, FNC1 in second or sixth position.
    DataMatrixD3Ecc200Fnc1SecondOrSixth,
    /// DataMatrix d4: ECC 200, ECI protocol implemented.
    DataMatrixD4Ecc200Eci,
    /// DataMatrix d5: ECC 200, FNC1 in first or fifth position, ECI protocol implemented.
    DataMatrixD5Ecc200Fnc1FirstOrFifthEci,
    /// DataMatrix d6: ECC 200, FNC1 in second or sixth position, ECI protocol implemented.
    DataMatrixD6Fnc1SecondOrSixthEci,
    /// GS1 DataBar Omnidirectional, GS1 DataBar Limited.
    DataBar,
    /// Unknown symbology.
    Unknown,
}

/// Decodes symbology type using AIM code identifiers.
///
/// # AIM codes
///
/// The AIM identifier is not part of a barcode. It is generated by the decoder of a scan engine to
/// represent the barcode symbology which was scanned.
///
/// Based on the AIM identifier, wedge software or terminal emulation software might be set up to
/// process scanned data in a user-defined way.
///
/// ## NOTE
///
/// Barcode scanners may also generate 1-character barcode identifiers instead of the
/// 3-character AIM identifier.
/// The actual characters used are defined by the manufacturer of that scan engine and might be
/// different, depending on that manufacturer.
///
/// Each AIM code identifier contains the three-character string `]cm` where:
///
/// * `]` &rArr; Flag Character (ASCII 93)
/// * `c` &rArr; Code Character
/// * `m` &rArr; Modifier Character
///
/// # Code characters
///
///
pub fn decode_aim_symbology(identifier: &[u8]) -> Symbology {
    match identifier {
        [0x5d, 0x64, 0x30] => Symbology::DataMatrixD0Ecc000140,
        [0x5d, 0x64, 0x31] => Symbology::DataMatrixD1Ecc200,
        [0x5d, 0x64, 0x32] => Symbology::DataMatrixD2Ecc200Fnc1FirstOrFifth,
        [0x5d, 0x64, 0x33] => Symbology::DataMatrixD3Ecc200Fnc1SecondOrSixth,
        [0x5d, 0x64, 0x34] => Symbology::DataMatrixD4Ecc200Eci,
        [0x5d, 0x64, 0x35] => Symbology::DataMatrixD5Ecc200Fnc1FirstOrFifthEci,
        [0x5d, 0x64, 0x36] => Symbology::DataMatrixD6Fnc1SecondOrSixthEci,
        [0x5d, 0x45, 0x30] => Symbology::DataBar,
        _ => Symbology::Unknown,
    }
}

#[tracing::instrument]
fn main() {
    // Set default logging level(s):
    if std::env::var_os("RUST_LOG").is_none() {
        std::env::set_var("RUST_LOG", "info,server_usb=trace");
    }
    FmtSubscriber::builder()
        .with_max_level(Level::TRACE)
        //.compact()
        //.json()
        .init();

    info!("Starting Server USB.");

    loop {
        info!("Initializing hidapi...");
        let hidapi_response = hidapi::HidApi::new();

        match hidapi_response {
            Ok(mut hidapi) => {
                info!("Looking for supported devices...");
                for device in hidapi.devices() {
                    if SUPPORTED_VIDS.contains(&device.vendor_id) {
                        info!("Found supported device: {:?}", device);
                    }
                }

                // Connect to device using its vid and pid
                let (vid, pid, serial_no) = (INTERMEC_VID, SG20_PID, "");

                loop {
                    info!(
                        "Trying to connect to device VID={:#04X?}, PID={:#04X?}, SN={} (Intermec SG20)...",
                        vid, pid, serial_no
                    );
                    let _res = hidapi.refresh_devices();
                    let device_res = hidapi.open_serial(vid, pid, serial_no);

                    match device_res {
                        Ok(device) => {
                            info!(
                                "Connected to device VID={:04X?}, PID={:04X?}, SN={}",
                                vid, pid, serial_no
                            );

                            // Read data from device
                            const BUFFER_SIZE: usize = 64 * 4; // TODO: Replace buffer size with max packet size from HID descriptor.
                            info!("Read buffer size is {} bytes.", BUFFER_SIZE);

                            // buffer for reading bytes from the HID device:
                            let mut buf = [0u8; BUFFER_SIZE];
                            // the number of bytes read so far from the current HID report:
                            let mut count_bytes_read_from_current_report: usize = 0;

                            loop {
                                info!("Waiting for device to send data...");
                                let read_result = device.read(&mut buf[..]);

                                match read_result {
                                    Ok(bytes_read_size) => {
                                        // the bytes that were read:
                                        let bytes = &buf[..bytes_read_size];
                                        debug!("Received (HEX): {:02X?}", &bytes);

                                        let terminator = {
                                            let mut t = [0u8; 3];
                                            t.copy_from_slice(
                                                &bytes[(bytes_read_size - 3)..bytes_read_size],
                                            );
                                            t
                                        };
                                        debug!("Terminator: {:02X?}", terminator);

                                        let symbology = {
                                            let mut s = [0u8; 3];
                                            s.copy_from_slice(&bytes[2..=4]);
                                            s
                                        };
                                        debug!(
                                            "Symbology {:02X?}={:?} is {:?}.",
                                            symbology,
                                            String::from_utf8_lossy(&symbology),
                                            decode_aim_symbology(&symbology),
                                        );

                                        match terminator {
                                            [0, 40, 1] => {
                                                count_bytes_read_from_current_report +=
                                                    *&bytes[..bytes_read_size].len();
                                                debug!(
                                                    "{} bytes read so far.",
                                                    count_bytes_read_from_current_report
                                                );
                                            }
                                            [0, 40, 0] => {
                                                info!("Finished reading HID report.");
                                                info!(
                                                    "{} bytes read in total.",
                                                    count_bytes_read_from_current_report
                                                );
                                                count_bytes_read_from_current_report = 0;
                                            }
                                            [0, 1, 0] => {
                                                info!("Finished reading HID report.");
                                                count_bytes_read_from_current_report +=
                                                    *&bytes[..bytes_read_size].len();
                                                info!(
                                                    "{} bytes read in total.",
                                                    count_bytes_read_from_current_report
                                                );
                                                count_bytes_read_from_current_report = 0;
                                            }
                                            other => {
                                                info!(
                                                    "Unknown termination bytes: {:?}={:02X?}",
                                                    other, other
                                                );
                                                count_bytes_read_from_current_report +=
                                                    *&bytes[..bytes_read_size].len();
                                                info!(
                                                    "{} bytes read (from unknown report size).",
                                                    count_bytes_read_from_current_report
                                                );
                                            }
                                        }
                                    }
                                    Err(e) => {
                                        info!("Error reading data from device: {:?}. Disconnecting and connecting back in 3 seconds.", e);
                                        std::thread::sleep(std::time::Duration::from_secs(3));
                                        break;
                                    }
                                }
                            }

                            // Write data to device
                            //            let buf = [0u8, 1, 2, 3, 4];
                            //            let hid_res = device.write(&buf);
                            //            match hid_res {
                            //                Ok(res) => {
                            //                    info!("Wrote: {:?} byte(s)", res);
                            //                }
                            //                Err(e) => {
                            //                    info!("Write error: {:?}", e);
                            //                }
                            //            }
                        }
                        Err(e) => {
                            info!("Device open error: {:?}. Reconnecting in 3 seconds.", e);
                            std::thread::sleep(std::time::Duration::from_secs(3));
                        }
                    }
                }
            }
            Err(e) => {
                info!(
                    "Failed to initialize hidapi: {:?}. Trying again in 10 seconds...",
                    e
                );
                std::thread::sleep(std::time::Duration::from_secs(10));
                continue;
            }
        }
    }
}
